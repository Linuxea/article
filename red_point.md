## 客户端的更新小红点实现

> 当后台系统对某个礼物进行更新或者添加新礼物时,客户端需要对这两种情况的礼物进行加红点提醒用户注意.当用户点击后则对红点进行取消.

看似一个很简单的需求,但是跟客户端对接过程中存在一些小问题,现总结如下吧.

## 第一种方案
将状态信息放在服务端,构成用户,礼物两者的关系,如下结构

用户id | 礼物id | 是否更新
------ | -----  | -------
123    |  234   |  yes


当有礼物添加或者更新时,则插入关系,同时提供接口给用户,当消除红点时进行数据删除.
此方案礼物更新时,可能需要将全部用户进行数据插入关联,成本较高.因此也可以换成状态默认为更新状态,同时是将用户已经非更新的状态保存下来.这样可将非活跃用户的数据不进行存储.

关联关系可存储在关系型数据库或者非关系型数据库.
但是总体的成本还是很高.

### 优点
- 直接
- 准确

### 缺点
- 实现复杂
- 代价较高,功能点重要性低


## 第二种方案
为每个礼物添加字段 <code>last_updated_time</code>,每次更新礼物配置也对此字段进行更新.
客户端本地礼物与接口获取的礼物列表进行匹配,如果更新时间比本地还新,则表示是礼物进行了更新,则进行红点展示.


### 优点
- 简单
### 缺点
- 本地首页启动时没有老版本礼物信息进行匹配,第一次没法区别哪种是更新过的礼物.


## 第三种方案
为每个礼物添加字段 <code>last_updated_time</code>,每次更新礼物配置也对此字段进行更新.
```sql
alter table table_name add column last_updated_time datetime default current_timestamp on update current_timestamp();
```

客户端保存一个本地时间,表示礼物的最后更新检查时间.
当客户端通过接口获取礼物数据时,如果某个礼物的最后更新时间＞本地保存的最后更新时间,或者礼物id是新增的,则表示此礼物是更新礼物.
展示红点,同时将本地保存的时间更新为当前时间.

麻烦的问题在于初始化的本地时间如何定义哪个时间点,写死在客户端,在测试与灰度的时候可能需要考虑重出现复更新红点给用户的错误现象,否则需要正式发版本又更新代码,
维护起来麻烦.在每次版本迭代时又需要将本地时间初始化更新的时间.

### 优点
- 简单快速代码量少
- 不需要与服务端进行交互

### 缺点
- 不够准确,初始化的本地时间需要定义清晰某个点
- 维护麻烦,每次发版本需要更新本地的初始化时间




## 第四种方案
作为第三种方案的改进,可将初始化的本地时间通过接口获取,由后台运营人员发版时进行配置.方便灵活.不需要写死在代码里面.

### 优点
- 简单成本低
- 交互少
### 缺点
- 无



## 总结
虽然只是一个很小的点,但是过程中发现问题也不少.关键还是在开发人员怎么思考,
小功能点上出现的问题大的功能点也一样会面临同样的思维误区.

如果一个功能点实现起来很麻烦,我想应该更多思考的是
- 是否有更简单的方案
- 是否需要做出合适的妥协来避免大的代价却获得少的成果

如果一个方案很复杂,甚至破坏之前的逻辑,没有遵守只增加不修改的设计原则,这样写出来的代码也只能满足一时的需求,后面的扩展与维护也会带来更多的麻烦.

 

























































